require 'helper'

class NetflowParserTest < Test::Unit::TestCase
  def setup
    Fluent::Test.setup
  end

  def create_parser(conf=nil)
    parser = Fluent::TextParser::NetflowParser.new
    parser.configure(conf || Fluent::Config::Element.new('ROOT', '', {}, []))
    parser
  end

  test 'configure' do
    assert_nothing_raised do
      parser = create_parser
    end
  end

  test 'parse v5 binary data, dumped by netflow-generator' do
    # generated by https://github.com/mshindo/NetFlow-Generator
    parser = create_parser
    raw_data = File.open(File.expand_path('../netflow.v5.dump', __FILE__)){|f| f.read }
    bytes_for_1record = 72
    assert_equal bytes_for_1record, raw_data.size
    parsed = []
    parser.call(raw_data) do |time, data|
      parsed << [time, data]
    end
    assert_equal 1, parsed.size
    assert_equal Time.parse('2016-02-29 11:14:00 -0800').to_i, parsed.first[0]
    expected_record = {
      # header
      "version" => 5,
      "flow_records" => 1,
      "flow_seq_num" => 1,
      "engine_type" => 1,
      "engine_id"   => 1,
      "sampling_algorithm" => 0,
      "sampling_interval"  => 0,

      # record
      "ipv4_src_addr" => "10.0.0.11",
      "ipv4_dst_addr" => "20.0.0.187",
      "ipv4_next_hop" => "30.0.0.254",
      "input_snmp"  => 1,
      "output_snmp" => 2,
      "in_pkts"  => 173,
      "in_bytes" => 4581,
      "first_switched" => "2016-02-29T19:14:00.089Z",
      "last_switched"  => "2016-02-29T19:14:00.090Z", # This value should be wrong, but assigned as is currently
      "l4_src_port" => 1001,
      "l4_dst_port" => 3001,
      "tcp_flags" => 27,
      "protocol" => 6,
      "src_tos"  => 0,
      "src_as"   => 101,
      "dst_as"   => 201,
      "src_mask" => 24,
      "dst_mask" => 24,
    }
    assert_equal expected_record, parsed.first[1]
  end

  DEFAULT_UPTIME = 1048383625 # == (((12 * 24 + 3) * 60 + 13) * 60 + 3) * 1000 + 625
  # 12days 3hours 13minutes 3seconds 625 milliseconds

  DEFAULT_TIME = Time.parse('2016-02-29 11:14:00 -0800').to_i
  DEFAULT_NSEC = rand(1_000_000_000)

  def msec_from_boot_to_time(msec, uptime: DEFAULT_UPTIME, sec: DEFAULT_TIME, nsec: DEFAULT_NSEC)
    current_time = Rational(sec) + Rational(nsec, 1_000_000_000)
    diff_msec = uptime - msec
    target_time = current_time - Rational(diff_msec, 1_000)
    Time.at(target_time)
  end

  def format_for_switched(time)
    time.utc.strftime("%Y-%m-%dT%H:%M:%S.%3NZ")
  end

  test 'switched time logic: it is wrong' do
    require 'ostruct'
    # 15:07:30.123456789
    current_time = Time.at(Rational(Time.parse('2016-02-29 15:07:30 -0800').to_i) + Rational(123_456_789, 1_000_000_000))
    # 1day 17hours 56minutes 42seconds 827milliseconds
    uptime = (((1 * 24 + 17) * 60 + 56) * 60 + 42) * 1000 + 827

    flowset = OpenStruct.new
    flowset.uptime = uptime
    flowset.unix_sec = current_time.to_i
    flowset.unix_nsec = current_time.nsec

    switched_time = ->(flowset, v){
      millis = flowset.uptime - v
      seconds = flowset.unix_sec - (millis / 1000)
      micros = (flowset.unix_nsec / 1000) - (millis % 1000)
      if micros < 0
        seconds -= 1
        micros += 1000000
      end
      Time.at(seconds, micros)
    }
    s1 = switched_time.(flowset, uptime - 19000) # 19 seconds ago
    s2 = switched_time.(flowset, uptime - 18500) # 18.5 seconds ago
    assert_equal 0.5, s2 - s1
  end

  test 'parse v5 binary data contains 1 record, generated from definition' do
    parser = create_parser
    parsed = []

    time1 = DEFAULT_TIME
    data1 = v5_data(
      version: 5,
      flow_records: 1,
      uptime: DEFAULT_UPTIME,
      unix_sec: DEFAULT_TIME,
      unix_nsec: DEFAULT_NSEC,
      flow_seq_num: 1,
      engine_type: 1,
      engine_id: 1,
      sampling_algorithm: 0,
      sampling_interval: 0,
      records: [
        v5_record,
      ]
    )

    parser.call(data1.to_binary_s) do |time, record|
      parsed << [time, record]
    end

    assert_equal 1, parsed.size
    assert_equal time1, parsed.first[0]

    event = parsed.first[1]

    assert_equal 5, event["version"]
    assert_equal 1, event["flow_records"]
    assert_equal 1, event["flow_seq_num"]
    assert_equal 1, event["engine_type"]
    assert_equal 1, event["engine_id"]
    assert_equal 0, event["sampling_algorithm"]
    assert_equal 0, event["sampling_interval"]

    assert_equal "10.0.1.122", event["ipv4_src_addr"]
    assert_equal "192.168.0.3", event["ipv4_dst_addr"]
    assert_equal "10.0.0.3", event["ipv4_next_hop"]
    assert_equal 1, event["input_snmp"]
    assert_equal 2, event["output_snmp"]
    assert_equal 156, event["in_pkts"]
    assert_equal 1024, event["in_bytes"]
    assert_equal format_for_switched(msec_from_boot_to_time(DEFAULT_UPTIME - 13000)), event["first_switched"]
    assert_equal format_for_switched(msec_from_boot_to_time(DEFAULT_UPTIME - 12950)), event["last_switched"]
    assert_equal 1048, event["l4_src_port"]
    assert_equal 80, event["l4_dst_port"]
    assert_equal 27, event["tcp_flags"]
    assert_equal 6, event["protocol"]
    assert_equal 0, event["src_tos"]
    assert_equal 101, event["src_as"]
    assert_equal 201, event["dst_as"]
    assert_equal 24, event["src_mask"]
    assert_equal 24, event["dst_mask"]
  end

  require 'fluent/plugin/netflow_records'
  def ipv4addr(v)
    addr = Fluent::TextParser::NetflowParser::IP4Addr.new
    addr.set(v)
    addr
  end

  def ipv6addr(v)
    addr = Fluent::TextParser::NetflowParser::IP6Addr.new
    addr.set(v)
    addr
  end

  def macaddr(v)
    addr = Fluent::TextParser::NetflowParser::MacAddr.new
    addr.set(v)
    addr
  end

  def mplslabel(v)
    label = Fluent::TextParser::NetflowParser::MplsLabel.new
    label.set(v)
    label
  end

  def v5_record(hash={})
    {
      ipv4_src_addr: "10.0.1.122",
      ipv4_dst_addr: "192.168.0.3",
      ipv4_next_hop: "10.0.0.3",
      input_snmp: 1,
      output_snmp: 2,
      in_pkts: 156,
      in_bytes: 1024,
      first_switched: DEFAULT_UPTIME - 13000, # 13seconds ago
      last_switched: DEFAULT_UPTIME - 12950, # 50msec later after first switched
      l4_src_port: 1048,
      l4_dst_port: 80,
      tcp_flags: 27,
      protocol: 6,
      src_tos: 0,
      src_as: 101,
      dst_as: 201,
      src_mask: 24,
      dst_mask: 24,
    }.merge(hash)
  end

  def v5_data(hash={})
    hash = hash.dup
    hash[:records] = (hash[:records] || []).map{|r|
      r = r.dup
      [:ipv4_src_addr, :ipv4_dst_addr, :ipv4_next_hop].each do |key|
        r[key] = ipv4addr(r[key]) if r[key]
      end
      r
    }
    Fluent::TextParser::NetflowParser::Netflow5PDU.new(hash)
  end

  def v9_template(hash)
  end

  def v9_option(hash)
  end

  def v9_data(hash)
  end
end
